## B
Чомусь спочатку думав, що можна за О(1) просто залишок від ділення порахувати та перевірити: `0 => No; else => Yes`. Також перевірити випадок, коли `x == 1 || y == 1`. Коли дійшло, що я щось взагалі не так розумію — відклав задачу і повернувся до неї після D. Переглянув приклади і на цей раз нормально зрозумів, що `count(turtles) + count(cranes) == x`, далі перебрати від 0 до x та знайти хоча б одне `turtles_count + cranes_count == y`.

## C
Зразу подумав, що треба перебрати `i = 0 to 101`, написав через 1 цикл, але всі тести не пройшло. Не думаючи, переписав через 2 цикли для `i = 0 to x` та `j = 100 downto x`.

## D
Зразу відкинув рішення за n<sup>2</sup>. Підрахував, що якщо для кожного a<sub>i</sub> шукати його дільники, то це влізе в обмеження, далі потрібно було швидко взнати, чи є дільник в входовому масиві `a`. Підрахував, що через `map` складність може бути завелика, взяв вектор. Надіслав, та отримав WA + TL, WA був через неопрацьований крайній випадок з `1` в даному масиві, TL через технічну помилку. З другої спроби здав задачу. 

## E - не здав
Спочатку треба підрахувати макс. рейтинги серед усіх дит. садків, далі нас в основному цікавлять вони, а особливо мінімальний з них та в якому він дит. садку. Умов, за яких щось змінюється небагато:

1. Мін. макс. рейтинг йде із садка А в Б =&gt; гарантовано мін. макс. стає наступний менший за ним в садку А
2. Якийсь рейтинг Х йде в садок, де знаходиться мін. макс. рейтинг
   1. Х &lt;= мін. макс. =&gt; нічого не змінюється
   2. Х &gt; мін. макс. =&gt; мін. макс. стає будь-який з нового набору максимальних з усіх дит. садків.
