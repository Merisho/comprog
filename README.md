## A
Перша думка була, якщо ж `y <= n`; та `y < x`, бо `y` - залишок, то просто вивести `k = y`. Але я не помітив, що нас питають найбільше `k`. Тому вирішив брати `r = n % x` та від цього відштовхуватись. Якщо `r == y`, то `k == n`. Якщо `r > y`, то відповідь більше, ніж `n - x`, якщо `r < y`, то відповідь менше, ніж `n - x` і т.д.

## B
Спочатку вирішив подивитись на випадки, коли неможливо дійти до 1. Відповідь `-1` якщо:
- число неможливо представити як `n = 2^a * 3^b`
- `a > b` (бо ми можемо лише ділити на `2 * 3` і множити на `2`, тоді в нас завжди буде якась степінь 2), це побачив не зразу
- після вилучення всіх степенів 2 і 3, n все ще не рівне 1

Далі рахуємо степені 2 і 3 (`a, b` відповідно). (Спочатку не побачив варіант з `a > b`, тому у коді брав `min, max` з `a, b`) :
- якщо `a == b`, то відповідь це значення (ділимо `a` разів на 6)
- якщо `b > a`, то відповідь `b + (b - a)`, так як спочатку зрівняємо степені, домноживши `b - a` разів на 2, потім поділимо на 6

## C
Колись зтикався з цією задачею при розборі якоїсь іншої, розв'язок розумію, написав одразу.

## D
Одразу зрозумів, що має сенс працювати з різницями `k - r[j]`, де `r[j] = a[i] % k, r[j] > 0`. Наступна ідея була відсортувати цей масив різниць (назовімо його `rd`) за зростанням, та робити наступне: йти по кожному `rd[i]` та збільшувати його на `k` доки `rd[i - 1] >= rd[i]`. Оскільки `rd` був відсортований, то після цих операцій маємо гарантовану умову `rd[i] > rd[i - 1]`. Тут стає зрозуміло, що треба дивитися на найбільший елемент, тобто `max = rd[rd.size() - 1]`. Щоб дібратися до нього нам потрібно підняти `x` до значення `max`, на це піде `max` операцій, та ще одна, щоб зробити останній хід, тобто `ans = max + 1`. Але у цьому розв'язку я не передбачив випадки, коли в нас є певні числа з `rd`, які однакові (такий тест є в Example). Далі мені спало на думку згрупувати елементи `rd` по значенню: `(value, count)`, та робити наступне: по колу забирати з кожної купки по 1 числу, збільшувати всі інші `value` на `k` (бо `x` в нас завжди росте на 1). Це завершується, коли в нас не залишається жодного елементу в усіх групах. Роблячи такі операції, я побачив, що треба вибрати елемент, який зустрічається найбільшу кількість разів у `rd`, якщо таких елементів декілька, то взяти найбільший з них (до цього була невдала спроба, коли я вибирав *тільки* найбільший елемент та кількість таких). Виконуючи операції забирання з кожної групи елемента по колу та збільшуючи значення всіх елементів на `k`, я прийшов до формули: `ans = md + (k * (mc - 1)) + 1`, `md = max(rd), count[md] = max(count)`. Тут не проходив вже 5ий тест. Побачив випадок, коли формула `ans` менша за максимальний `rd`, пофіксив. Лишалось мало часу та, без доказу що таке можливо, додав фікс для `ans == max(rd)`, так і не пройшло 5ий тест.
