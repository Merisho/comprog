## C
Тут виникли проблеми. Кількість різних імен із `n` літер це 26<sup>n</sup>. Але тут є певний offset, який збивав мене з пантелику. Не міг ніяк вирішити, як шукати ім'я: чи спочатку порахувати його довжину, чи спочатку знайти проміжок, на якому воно знаходиться. Але проміжок може бути завеликим і коли його знайдемо, то тупий перебір не влізе в обмеження. Побачив, що `start % 26 == 1`, `end % 26 == 0`, де start - початок якогось проміжку, end - кінець. Але ніяк особливо не допомогло. Виразив кінець і-того проміжку через рекурентну формулу, але зрозумів, що проміжок, на якому лежить n нам не допоможе. Далі спало на думку шукати ім'я так, як шукається двійкове число з десяткового: ділити на 26, остача вказує на літеру. Це справа-наліво дозволяє знайти що просять, але ще застряг на випадку, коли остача == 0 (літера `z`). Опрацював це окремо та здав задачу.

## D
Зразу стало зрозуміло, що треба підрахувати к-сті унікальних чисел і початкову суму. Далі віднімати від суми та додавати, щоб не рахувати одне й теж саме.

## E
Помітив, що якщо в `n - 1` чисел вихідного масиву `b` непарна кількість 1 в j-тому біті, то це нам дасть 1 в j-тому біті в `a[i]`. Далі побачив наступне: якщо в `a[i]` і `a[i + 1]` в одному і тому самому біті різні числа (1 та 0, 0 та 1 відповідно), то це значить, що в тій самій позиції в `b[i]` і `b[i + 1]` також будуть різні числа. Ну а десь біти будуть однакові. Можливо, побудувавши певну структуру даних, ми зможемо вияснити які біти в яких `b[i]` однакові, а які різні. Далі якось підставивши 0 та 1 в кожний біт можемо застосувати певну функцію, яка на основі однаковості-неоднаковості бітів побудує нам числа з масиву `b`. Як підставляти 0 чи 1 ще не придумав. Також тут треба якось застосувати те, що умова гарантує парніть вхідного `n`.
