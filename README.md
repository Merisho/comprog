## A
Спочатку допустив, якщо n - парне, то YES, інакше NO. Розглянув випадок шестикутника і зрозумів, що треба перевіряти чи `n % 4 == 0`

## B
На цю задачу витратив забагато часу (здав на 33й хвилині, на 31й хвилині була 1 невірна спроба через неуважність). Плутались думки, я на себе тиснув і ще більше плутався. Почав розглядати всі варіанти вхідних строк і що ми маємо отримати з кожного варіанту, відповідно. Спочатку подумав, що треба рахувати кількість `...10...`, тобто послідовність 1 і потім перехід на послідовність 0. І потім вивести цю ж кількість нулів + одиниці, які є в кінці (якщо є). Тобто `101010111` мало б дати `000111`. Але побачив, що це неоптимально, т.я. роблячи дещо інші ходи можна отримати `0111`. І тоді зрозумів, що будь-яку послідовність `10` можна звести до одного 0. Кінцева відповідь буде: (всі перші 0, які стоять перед першою 1) + (один 0, якщо є хоча б одна пара 10) + (всі 1, які стоять в кінці).

## C
Перша думка була така: відсортувати за зростанням `a`, за спаданням `w`. Далі робимо наступне: беремо останні `w[i]` елементів з `a`, які ще не були взяті, додаємо до суми мін. і макс. з них. Це не пройшло другий example тест. Довго крутив, по різному беручи суми, не міг зрозуміти, що робити з відсортованими масивами. Далі побачив, що нам не вигідно пропускати найбільші елементи з `a`, а якісь елементи все одно пропускаються, т.я. нас цікавить тільки мін. і макс. Також має сенс `w[i] == 1 || w[i] == 2` опрацьовувати окремо, бо вони дають найбільший приріст до суми. Допустив, що тоді можна не сортувати `w`, написав це рішення і не пройшло на 2 тесті: https://codeforces.com/contest/1369/submission/84799667

Розбирав свій алгоритм з іншим випадком на листочку, та зрозумів, що потрібно опрацювати спочатку всі `w[i]`, котрі `w[i] == 1 || w[i] == 2`, а потім йти по `w` в порядку спадання, вибираючи елементи таким чином: 1 найбільший справа, `w[i] - 1` менших зліва. В порядку спадання тому, що напочатку відсортованого `a` знаходяться найменші елементи, беручи якомога більше `w[i]` ми пропускаємо більшу кількість цих найменших елементів, даючи наступним `w[i + 1]` більше мінімальне значення, тим самим збільшуючи суму.

## D
Справа не у самому графі, оскільки нам дано одне єдине `n`, то треба зрозуміти закономірність зміни кількості _claws_. Особливих думок не було, не вистачило часу.
