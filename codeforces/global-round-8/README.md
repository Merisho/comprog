## A
Пару хвилин покрутив як треба додавати, щоб за найменшу к-сть набрати > n, побачив теж саме, що послідовність Фібоначчі, але з іншими стартовими числами.

## B
Спочатку подумав, що можна просто `s` додавати в кінець `codeforces`, потім поглянув на те, як впливає на к-сть підпослідовностей ще 2 літери `c` та `o` (`ccoodeforcess`). Виявилось, що це просто добуток кількостей усіх літер, так як це нам дасть кількість усіх можливих комбінацій.

## C
Спочатку думав, що має сенс будувати прямокутник, і окремо опрацювати випадок, коли `n % 2 == 1`. Писав код хвилин 20-25, надіслав і отримав помилку на 2 претесті. Через декілька хвилин зрозумів, що я не побачив очевидну річ (коли к-сть сірих клітин в одному рядку чи стовпці на межах прямокутника > 2, то ми маємо хоча б одну сіру клітину з непарною кількістю сусідних сірих). Деякий час намагався зрозуміти як краще будувати - не придумав і перейшов до задачі D. Потім повернувся до C і зрозумів, що треба будувати ромб, у якого "кути" згори-знизу-зліва-справа складаються з максимум 2х клітин. Оскільки нас не обмежують умовою задачі в кількості сірих клітин, то ми завжди можемо підігнати так, щоб змогти побудувати ромб. Тоді вийде так, що всі клітини, що всередині ромбу мають 4 сірих сусіди, в той час, як ті, що на межі, матимуть 2 сірих сусіди.

   **   
  ****  
 ****** 
********
********
 ****** 
  ****  
   **   

## D
Нічого значного не придумав, тільки допустив, що можемо відсортувати і подивитись як це нам допоможе. Також розглядав окремі біти, корисного чогось не побачив (щоб можна було застосувати з даними обмеженнями).
